
==================== FINAL INTERFACE ====================
2018-03-04 00:58:39.6339576 UTC

interface main:Main 8022
  interface hash: a4ad13d613007694756f803a3151150a
  ABI hash: d434db35e3496a96c0c2596b872a103f
  export-list hash: a078207187d0f482cfabdf7af3e7bb7a
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 49bc03923b6b72218773bcd45aaea9d8
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.forcedValid
  Main.main
  Main.makeSolution
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0 jkfso-haskell-0.1.0.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.List e5312e282ad78d8152090e079f862b53
import  -/  base-4.10.1.0:Data.OldList fdea655c7bec488a3994df222c677ab7
import  -/  base-4.10.1.0:GHC.Base 8f949d675e49677c272f02ab7a85fe18
import  -/  base-4.10.1.0:GHC.Show 927ef590f679632bf94869e8018e5b48
import  -/  base-4.10.1.0:Prelude a93a9400cc0c816c2ee5f39399baa7a0
import  -/  base-4.10.1.0:System.Environment 29b8ecc18446119a33172a40409ab016
import  -/  base-4.10.1.0:System.IO 1fb8f1d116df69c8750950ac088a90e6
import  -/  ghc-prim-0.5.1.1:GHC.Types b1fd0716441595db508c1a74387bf394
import  -/  jkfso-haskell-0.1.0.0:HardConstraints e86f0562cd4f59435032f24663722785
import  -/  jkfso-haskell-0.1.0.0:Input 46f4d1b6920570870efd4da2af99945d
import  -/  jkfso-haskell-0.1.0.0:Parser ba8cf5c0a267e1877583f0e62abb5c20
import  -/  jkfso-haskell-0.1.0.0:SoftConstraints cde4088db7616bf2acf005307498fe18
9d72b2fddb818bcd8919052935e0f1f3
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
3108ceeaf5a318be844de422b45de9d8
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
33bd129667974f0a0ba4a893af79107d
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
7fde8baba86b27f7a99a5ed2aad84554
  forcedValid ::
    [(GHC.Types.Char, GHC.Types.Char)]
    -> [(GHC.Types.Char, GHC.Types.Char)]
    -> [(GHC.Types.Char, GHC.Types.Char)]
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
  {- Arity: 4, Strictness: <S,U><L,U><L,U><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ (forcedPairs :: [(GHC.Types.Char, GHC.Types.Char)])
                   (forbidPairs :: [(GHC.Types.Char, GHC.Types.Char)])
                   (tooNearPairs :: [(GHC.Types.Char, GHC.Types.Char)])
                   (matches :: [GHC.Types.Char]) ->
                 case HardConstraints.forcedDoubles forcedPairs of wild {
                   GHC.Types.False -> Main.forcedValid1
                   GHC.Types.True
                   -> HardConstraints.makeForced
                        forcedPairs
                        forbidPairs
                        tooNearPairs
                        matches }) -}
719b543e5d57ebfba64813d368197b3f
  forcedValid1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.forcedValid2) -}
f3b9c383eb83b0dca732d670ee675b04
  forcedValid2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("No solution possible!"#) -}
16c8b5a7e0fffcc12f6a3958110c69b9
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
9b4b21b4c54864445b1f4f79758c75aa
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (Foreign.Marshal.Alloc.allocaBytesAligned
                         @ Foreign.C.Types.CInt
                         @ (GHC.Base.Maybe [GHC.Base.String])
                         Foreign.Storable.$fStorableBool7
                         Foreign.Storable.$fStorableBool7
                         System.Environment.getArgs2
                           `cast`
                         (<GHC.Ptr.Ptr Foreign.C.Types.CInt>_R
                          ->_R Sym (GHC.Types.N:IO[0] <GHC.Base.Maybe [GHC.Base.String]>_R)))
                        `cast`
                      (GHC.Types.N:IO[0] <GHC.Base.Maybe [GHC.Base.String]>_R)
                        s of ds2 { (#,#) ipv ipv1 ->
                 case ipv1 of wild {
                   GHC.Base.Nothing
                   -> case GHC.Environment.getFullArgs1
                             ipv of ds3 { (#,#) ipv2 ipv3 ->
                      Main.main2
                        ipv2
                        (case System.Environment.dropRTSArgs ipv3 of wild1 {
                           [] -> GHC.List.scanl2 @ GHC.Base.String : ds4 xs -> xs }) }
                   GHC.Base.Just argv
                   -> Main.main2 ipv (GHC.List.tail @ GHC.Base.String argv) } }) -}
01401f56b02d35ad2529bd7c50405616
  main2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> [GHC.Base.String]
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,U><L,U> -}
77b2e632fc996b949cdd4c2d7e790047
  main3 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
17f0da055445755e10bb07630ced7dc5
  makeSolution :: GHC.Base.String -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,1*U(U)>,
     Unfolding: (\ (matches :: GHC.Base.String)
                   (quality :: GHC.Types.Int) ->
                 GHC.CString.unpackAppendCString#
                   Main.makeSolution3
                   (let {
                      n :: [GHC.Types.Char]
                      = GHC.CString.unpackAppendCString#
                          Main.makeSolution2
                          (case quality of ww2 { GHC.Types.I# ww3 ->
                           case GHC.Show.$wshowSignedInt
                                  0#
                                  ww3
                                  (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                           GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                    } in
                    case matches of wild {
                      [] -> n
                      : x xs
                      -> GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.:
                              @ GHC.Types.Char
                              x
                              (Data.OldList.prependToAll @ GHC.Types.Char Main.makeSolution1 xs))
                           n })) -}
a268d5891b483cd88ebd517c05f16148
  makeSolution1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' '#) -}
7dc59637e5c84f05031c1a93eac29955
  makeSolution2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("; Quality: "#) -}
1fd871e2134038b43f7ddceb5ab9f72f
  makeSolution3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Solution: "#) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

