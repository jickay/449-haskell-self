
==================== FINAL INTERFACE ====================
2018-03-04 00:58:37.4975455 UTC

interface jkfso-haskell-0.1.0.0-9wfP2njLanP40orVtGiOyG:SoftConstraints 8022
  interface hash: e4e5cace0c7b8788e342fba8a0fefe35
  ABI hash: cde4088db7616bf2acf005307498fe18
  export-list hash: 2c027a5a844251e3eb937a1367a5b3c5
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: c98e1eb85fe7ed81c2ec56ee6ec1ed45
  sig of: Nothing
  used TH splices: False
  where
exports:
  SoftConstraints.compareMatches
  SoftConstraints.expandMatches
  SoftConstraints.fillRound
  SoftConstraints.fillX
  SoftConstraints.getFreeTasks
  SoftConstraints.getIndex
  SoftConstraints.getNearPen
  SoftConstraints.getQual
  SoftConstraints.getRounds
  SoftConstraints.iterateMatches
  SoftConstraints.machines
  SoftConstraints.minIndex
  SoftConstraints.tasks
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.Foldable 4349255461f1285ad885cd2301205c36
import  -/  base-4.10.1.0:Data.List e5312e282ad78d8152090e079f862b53
import  -/  base-4.10.1.0:Data.OldList fdea655c7bec488a3994df222c677ab7
import  -/  base-4.10.1.0:GHC.Base 8f949d675e49677c272f02ab7a85fe18
import  -/  base-4.10.1.0:GHC.List 1bb0adf79553530dc898796596e53188
import  -/  base-4.10.1.0:GHC.Num bee60808f8127e4cda82dd422aa1c6c0
import  -/  base-4.10.1.0:GHC.Show 927ef590f679632bf94869e8018e5b48
import  -/  base-4.10.1.0:Prelude a93a9400cc0c816c2ee5f39399baa7a0
import  -/  ghc-prim-0.5.1.1:GHC.Classes 64ad5910d03ab188ab9b4adef7487b1e
ef3d9b239a88c87d0f9c408bbd56ad95
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   SoftConstraints.$trModule3
                   SoftConstraints.$trModule1) -}
e23db0088b2d19bf268bb8aa69888a71
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SoftConstraints.$trModule2) -}
2e54a10081e36ed3622b5bcb2e3fee4d
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SoftConstraints"#) -}
9dec5c64d219886d477fc63e6ce1c706
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS SoftConstraints.$trModule4) -}
00673d5bef359e7de37f40d72f7cd2cf
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("jkfso-haskell-0.1.0.0-9wfP2njLanP40orVtGiOyG"#) -}
62393981892c6eec83aa6f3c7118d4ec
  $wcompareMatches ::
    [[GHC.Types.Char]] -> [[GHC.Types.Int]] -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (w :: [[GHC.Types.Char]])
                   (w1 :: [[GHC.Types.Int]]) ->
                 case w of wild {
                   [] -> SoftConstraints.compareMatches1
                   : ipv ipv1
                   -> case Data.OldList.findIndex
                             @ [GHC.Types.Char]
                             (GHC.Base.eqString
                                (letrec {
                                   go :: [[GHC.Types.Char]] -> [GHC.Types.Char] -> GHC.Base.String
                                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U> -}
                                   = \ (ds :: [[GHC.Types.Char]]) (eta :: [GHC.Types.Char]) ->
                                     case ds of wild1 {
                                       [] -> eta
                                       : y ys
                                       -> case SoftConstraints.$wgetQual y w1 of ww { DEFAULT ->
                                          case SoftConstraints.$wgetQual eta w1 of ww1 { DEFAULT ->
                                          case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.># ww ww1) of wild2 {
                                            GHC.Types.False -> go ys y
                                            GHC.Types.True -> go ys eta } } } }
                                 } in
                                 go ipv1 ipv))
                             wild of wild1 {
                        GHC.Base.Nothing -> SoftConstraints.compareMatches1
                        GHC.Base.Just x -> x } }) -}
df425815ee2c874328e8cbdc61a8452d
  $wfillX ::
    GHC.Prim.Int#
    -> [GHC.Types.Int] -> [GHC.Types.Char] -> GHC.Types.Char
  {- Arity: 3, Strictness: <S,U><S,1*U><L,U>, Inline: [0] -}
7c4fe8a0c582db4e93553c2250489fd7
  $wgetQual :: [GHC.Types.Char] -> [[GHC.Types.Int]] -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
455e13b5a1c88f416cdd67e41a6d8460
  $witerateMatches ::
    [GHC.Types.Char] -> [[GHC.Types.Int]] -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
e14ddaa844d44f55b04a66a2050562d2
  $wminIndex :: [GHC.Types.Int] -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [GHC.Types.Int]) ->
                 case w of wild {
                   [] -> case GHC.List.minimum2 ret_ty GHC.Prim.Int# of {}
                   : ipv ipv1
                   -> case ipv of ww { GHC.Types.I# ww1 ->
                      case GHC.List.$wgo1 ipv1 ww1 of ww2 { DEFAULT ->
                      letrec {
                        go :: GHC.Prim.Int# -> GHC.Prim.Int#
                          <join 1> {- Arity: 1, Strictness: <S,U> -}
                        = \ (x :: GHC.Prim.Int#) ->
                          case GHC.List.$w!!
                                 @ GHC.Types.Int
                                 wild
                                 x of wild1 { GHC.Types.I# x1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.==# x1 ww2) of wild2 {
                            GHC.Types.False
                            -> case x of wild3 {
                                 DEFAULT -> go (GHC.Prim.+# wild3 1#)
                                 9223372036854775807#
                                 -> case GHC.List.badHead ret_ty GHC.Prim.Int# of {} }
                            GHC.Types.True -> x } }
                      } in
                      go 0# } } }) -}
c9c292330c8d034d7e9366073a5d0b17
  compareMatches ::
    [[GHC.Types.Char]]
    -> [[GHC.Types.Int]]
    -> [(GHC.Types.Char, GHC.Types.Char, GHC.Types.Int)]
    -> GHC.Types.Int
  {- Arity: 3, Strictness: <S,1*U><L,U><L,A>, Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: [[GHC.Types.Char]])
                   (w1 :: [[GHC.Types.Int]])
                   (w2 :: [(GHC.Types.Char, GHC.Types.Char, GHC.Types.Int)]) ->
                 SoftConstraints.$wcompareMatches w w1) -}
81ab919ee13d4dc950f2f4e7ce45ddee
  compareMatches1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
7885be9fb02864d4d3cec33996b7cb39
  expandMatches ::
    GHC.Types.Int
    -> [GHC.Types.Char] -> [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,1*U> -}
d615ceb3a93954d84b9fd712177e926f
  fillRound ::
    [GHC.Types.Char]
    -> [[GHC.Types.Int]] -> [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
441d82e06cee8bff410445dbd4643868
  fillX ::
    GHC.Types.Int
    -> [GHC.Types.Int] -> [GHC.Types.Char] -> GHC.Types.Char
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: [GHC.Types.Int])
                   (w2 :: [GHC.Types.Char]) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 SoftConstraints.$wfillX ww1 w1 w2 }) -}
9d987fa3df4fa28ba225dbf22a6681a4
  getFreeTasks ::
    [GHC.Types.Char] -> [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
d9039b7e08c087962e742d794ee69c66
  getIndex :: GHC.Base.Maybe GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (mx :: GHC.Base.Maybe GHC.Types.Int) ->
                 case mx of wild {
                   GHC.Base.Nothing -> SoftConstraints.compareMatches1
                   GHC.Base.Just x -> x }) -}
fc86e10e2db3e8b13147152e1bff9647
  getNearPen ::
    GHC.Types.Char
    -> GHC.Types.Char
    -> [(GHC.Types.Char, GHC.Types.Char, GHC.Types.Int)]
    -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>m,
     Unfolding: InlineRule (3, True, True)
                (\ (a :: GHC.Types.Char)
                   (b :: GHC.Types.Char)
                   (c :: [(GHC.Types.Char, GHC.Types.Char, GHC.Types.Int)]) ->
                 SoftConstraints.compareMatches1) -}
4b41dcdf632c034efe4f82fe9d697d99
  getQual ::
    [GHC.Types.Char]
    -> [[GHC.Types.Int]]
    -> [(GHC.Types.Char, GHC.Types.Char, GHC.Types.Int)]
    -> GHC.Types.Int
  {- Arity: 3, Strictness: <S,1*U><L,U><L,A>m, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: [GHC.Types.Char])
                   (w1 :: [[GHC.Types.Int]])
                   (w2 :: [(GHC.Types.Char, GHC.Types.Char, GHC.Types.Int)]) ->
                 case SoftConstraints.$wgetQual w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
a2240e0276f30158616ac2e003004d84
  getRounds ::
    [[GHC.Types.Char]] -> [[GHC.Types.Int]] -> [[GHC.Types.Char]]
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
5a87f177b5b3117ea852a3b8feb82a80
  iterateMatches ::
    [GHC.Types.Char]
    -> [[GHC.Types.Int]]
    -> [(GHC.Types.Char, GHC.Types.Char, GHC.Types.Int)]
    -> [GHC.Types.Char]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,A>, Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: [GHC.Types.Char])
                   (w1 :: [[GHC.Types.Int]])
                   (w2 :: [(GHC.Types.Char, GHC.Types.Char, GHC.Types.Int)]) ->
                 SoftConstraints.$witerateMatches w w1) -}
c8f2249cf341b5e3e3a9f4b08d7617e6
  machines :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SoftConstraints.machines1) -}
11960aa9ea15f14bff90541e54f5fc51
  machines1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("12345678"#) -}
1fc537f12e06177a565d495cd529f3f3
  minIndex :: [GHC.Types.Int] -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [GHC.Types.Int]) ->
                 case SoftConstraints.$wminIndex w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
261b68d8e1f6b32bb78425c420aa8135
  tasks :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   SoftConstraints.tasks1) -}
e06fbf10337d44be28e8b1df64ce38c1
  tasks1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ABCDEFGH"#) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

