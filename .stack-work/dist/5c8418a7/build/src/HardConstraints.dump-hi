
==================== FINAL INTERFACE ====================
2018-02-28 03:51:18.248307 UTC

interface jkfso-haskell-0.1.0.0-9wfP2njLanP40orVtGiOyG:HardConstraints 8022
  interface hash: dc17b9f3abe5414c68238c443c293191
  ABI hash: 2c08b34583cf3d729d1c325293aa88f5
  export-list hash: 7fa4402d647dbb845bf310cfa922a3c2
  orphan hash: 37381a75cf0e7e7b96c45fcb5089ad9f
  flag hash: c98e1eb85fe7ed81c2ec56ee6ec1ed45
  sig of: Nothing
  used TH splices: False
  where
exports:
  HardConstraints.checkForbid
  HardConstraints.forcedDoubles
  HardConstraints.getMachs
  HardConstraints.getTasks
  HardConstraints.makeForced
  HardConstraints.makePair
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.Foldable 4349255461f1285ad885cd2301205c36
import  -/  base-4.10.1.0:Data.Tuple ab0c62ebfcacf00dcba54934885c5064
import  -/  base-4.10.1.0:GHC.Base 8f949d675e49677c272f02ab7a85fe18
import  -/  base-4.10.1.0:GHC.List 1bb0adf79553530dc898796596e53188
import  -/  base-4.10.1.0:GHC.Num bee60808f8127e4cda82dd422aa1c6c0
import  -/  base-4.10.1.0:Prelude a93a9400cc0c816c2ee5f39399baa7a0
import  -/  base-4.10.1.0:Text.Read c150617dda21a009ed26981626bd21d7
c4da82b47973077ebac4cd01984eb814
  $s$fEq(,) :: GHC.Classes.Eq (GHC.Types.Char, GHC.Types.Char)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Char, GHC.Types.Char)
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Types.Char
                     @ GHC.Types.Char
                     GHC.Classes.$fEqChar
                     GHC.Classes.$fEqChar)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ GHC.Types.Char
                     @ GHC.Types.Char
                     GHC.Classes.$fEqChar
                     GHC.Classes.$fEqChar) -}
8d7a0647458a5f14e8e3c36e67739869
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   HardConstraints.$trModule3
                   HardConstraints.$trModule1) -}
ff0c630544645661ce3e6befd819e75d
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS HardConstraints.$trModule2) -}
fa90a04292e40dbcf0bf27a6b14a7221
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HardConstraints"#) -}
e5c6159a2c0a8e391c15425c00aeff37
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS HardConstraints.$trModule4) -}
6b6898041ca2ac691a6b364bdb94cc41
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("jkfso-haskell-0.1.0.0-9wfP2njLanP40orVtGiOyG"#) -}
d1bea667dff7a1514a76616c81b3b706
  checkForbid ::
    (GHC.Types.Char, GHC.Types.Char)
    -> [(GHC.Types.Char, GHC.Types.Char)] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: (GHC.Types.Char, GHC.Types.Char))
                   (forbidden :: [(GHC.Types.Char, GHC.Types.Char)]) ->
                 GHC.List.elem
                   @ (GHC.Types.Char, GHC.Types.Char)
                   HardConstraints.$s$fEq(,)
                   x
                   forbidden) -}
5cffa754743e25d7b5684a74481025f5
  forcedDoubles ::
    [(GHC.Types.Char, GHC.Types.Char)] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b94c7fffac7296386d685b9785d9e0bd
  getMachs :: [(GHC.Types.Char, GHC.Types.Char)] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
98203e5bb2809c715ae03f5d4ddb904b
  getTasks :: [(GHC.Types.Char, GHC.Types.Char)] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (HardConstraints.getMachs) -}
40461d1144faaddf17af51538c4eb16b
  makeForced ::
    [(GHC.Types.Char, GHC.Types.Char)]
    -> [(GHC.Types.Char, GHC.Types.Char)]
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,1*U> -}
a7cfaa0514c984d7db4896065044c121
  makePair ::
    (GHC.Types.Char, GHC.Types.Char)
    -> [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <L,U(1*U,1*U)><L,1*U>,
     Unfolding: (\ (x :: (GHC.Types.Char, GHC.Types.Char))
                   (matches :: [GHC.Types.Char]) ->
                 case Text.Read.readEither8
                        @ GHC.Types.Int
                        (Text.ParserCombinators.ReadP.run
                           @ GHC.Types.Int
                           HardConstraints.makePair3
                           (GHC.Types.:
                              @ GHC.Types.Char
                              (case x of wild { (,) x1 ds1 -> x1 })
                              (GHC.Types.[] @ GHC.Types.Char))) of wild {
                   [] -> case HardConstraints.makePair2 ret_ty [GHC.Types.Char] of {}
                   : x1 ds
                   -> case ds of wild1 {
                        []
                        -> case x1 of wild2 { GHC.Types.I# x2 ->
                           let {
                             x3 :: GHC.Prim.Int# = GHC.Prim.-# x2 1#
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<=# x3 0#) of wild3 {
                             GHC.Types.False
                             -> case matches of wild4 {
                                  []
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       (GHC.Types.[] @ GHC.Types.Char)
                                       (GHC.Types.:
                                          @ GHC.Types.Char
                                          (case x of wild5 { (,) ds1 y -> y })
                                          (GHC.List.scanl2 @ GHC.Types.Char))
                                  : ipv ipv1
                                  -> case x3 of ds1 {
                                       DEFAULT
                                       -> let {
                                            ds2 :: ([GHC.Types.Char], [GHC.Types.Char])
                                            = case GHC.List.splitAt_$s$wsplitAt'
                                                     @ GHC.Types.Char
                                                     ipv1
                                                     (GHC.Prim.-# ds1 1#) of ww { (#,#) ww1 ww2 ->
                                              (ww1, ww2) }
                                          } in
                                          GHC.Base.++
                                            @ GHC.Types.Char
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               ipv
                                               (case ds2 of wild5 { (,) xs' xs'' -> xs' }))
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               (case x of wild5 { (,) ds4 y -> y })
                                               (case ds2 of wild5 { (,) xs' xs'' ->
                                                case xs'' of wild6 {
                                                  [] -> GHC.List.scanl2 @ GHC.Types.Char
                                                  : ds4 xs -> xs } }))
                                       1#
                                       -> GHC.Base.++
                                            @ GHC.Types.Char
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               ipv
                                               (GHC.Types.[] @ GHC.Types.Char))
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               (case x of wild5 { (,) ds2 y -> y })
                                               (case ipv1 of wild5 {
                                                  [] -> GHC.List.scanl2 @ GHC.Types.Char
                                                  : ds2 xs -> xs })) } }
                             GHC.Types.True
                             -> GHC.Base.++
                                  @ GHC.Types.Char
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     (case x of wild4 { (,) ds1 y -> y })
                                     (case matches of wild4 {
                                        [] -> GHC.List.scanl2 @ GHC.Types.Char
                                        : ds1 xs -> xs })) } }
                        : ipv ipv1
                        -> case HardConstraints.makePair1
                           ret_ty [GHC.Types.Char]
                           of {} } }) -}
7e958663f9a6124ccef3c28c876eff92
  makePair1 :: GHC.Types.Int
  {- Strictness: x -}
ed975b47cd696eb6241a7a15eb36f640
  makePair2 :: GHC.Types.Int
  {- Strictness: x -}
055c1de6c56189f5eafa948a27c6ffe0
  makePair3 :: Text.ParserCombinators.ReadP.P GHC.Types.Int
  {- Unfolding: (GHC.Read.$fReadInt_$sreadNumber
                   GHC.Read.$fReadInt2
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Int
                   (Text.Read.readEither7 @ GHC.Types.Int)) -}
"SPEC/HardConstraints $fEq(,) @ Char @ Char" [orphan] forall (v1 :: GHC.Classes.Eq
                                                                      GHC.Types.Char)
                                                             (v :: GHC.Classes.Eq GHC.Types.Char)
  GHC.Classes.$fEq(,) @ GHC.Types.Char @ GHC.Types.Char v v1
  = HardConstraints.$s$fEq(,)
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

